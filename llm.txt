4.1. 테스트 기법 개요
테스트 기법은 테스터의 테스트 분석(무엇을 테스트할지)과 테스트 설계(어떻게 테스트할지) 작업을 지원한다. 테스트 기법은 적은 수이지만, 충분한 테스트 케이스를 체계적인 방식으로 개발할 수 있도록 해준다. 또한, 테스트 기법은 테스터가 테스트 분석과 설계에서 테스트 컨디션을 정의하고, 커버리지 항목과 테스트 데이터를 식별하는 데 도움을 준다. 테스트 기법에 관한 보다 자세한 정보는 ISO/IEC/IEEE 29119-4 표준과 Beizer 1990, Craig 2002, Copeland 2004, Koomen 2006, Jorgensen 2014, Ammann 2016, Forgács 2019를 참조할 수 있다.
이 실러버스는 테스트 기법을 블랙박스, 화이트박스, 경험 기반으로 분류하고 있다.
블랙박스 테스트 기법(명세 기반 기법이라고도 함)은 내부 구조를 참조하지 않고, 테스트 대상의 명시된 동작에 대한 분석을 기반으로 한다. 따라서 테스트 케이스는 소프트웨어 구현 방식에 의존하지 않는다. 결국 구현이 바뀌더라도 필요한 동작이 동일하다면, 테스트 케이스는 여전히 유효하게 된다.
화이트박스 테스트 기법(구조 기반 기법이라고도 함)은 테스트 대상의 내부 구조와 처리에 대한 분석을 기반으로 한다. 테스트 케이스는 소프트웨어 설계 방식에 의존하기 때문에 테스트 대상의 설계나 구현이 끝난 후에 만들 수 있다.
경험 기반 테스트 기법은 테스터의 지식과 경험을 테스트 케이스의 설계 및 구현에 효과적으로 활용하게 한다. 이런 기법의 효과성은 테스터의 능력에 따라 크게 달라진다. 경험 기반 테스트 기법은 블랙박스 테스트 기법과 화이트박스 테스트 기법으로는 식별하지 못할 수 있는 결함을 찾을 수 있게 해준다. 따라서 경험 기반 테스트 기법은 블랙박스 테스트 기법과 화이트박스 테스트 기법을 보완한다.

4.2. 블랙박스 테스트 기법
많이 사용되는 블랙박스 테스트 기법은 다음과 같다:
• 동등 분할
• 경계값 분석
• 결정 테이블 테스팅
• 상태 전이 테스팅
4.2.1. 동등 분할
동등 분할(EP)은 테스트 대상이 하나의 분할(동등 분할이라고도 함)에 포함된 모든 요소를 동일한 방식으로 처리할 것이라는 가정하에 데이터를 분할 단위로 나눈다. 이 기법의 근거 이론은 동등 분할에 속한 특정 값을 테스트하는 테스트 케이스로 결함을 식별할 수 있다면, 같은 동등 분할의 다른 어떤 값을 테스트하는 테스트 케이스라도 해당 결함을 식별할 수 있어야 한다는 것이다. 따라서 각 분할에 대해 하나의 테스트만 수행하면 충분하다.
동등 분할은 입력, 출력, 형상 항목, 내부 값, 시간 관련 값, 인터페이스 매개변수 등 테스트 대상과 관련된 모든 데이터 요소에 대해 식별할 수 있다. 분할은 연속적이거나, 연속적이지 않을 수도 있으며, 정렬돼 있거나, 유한 또는 무한일 수도 있다. 분할은 서로 겹치지 않아야 하며, 값이 없는 공집합일 수는 없다.
단순한 테스트 항목의 경우, 동등 분할을 적용하기가 쉬울 수 있지만, 실제로는 테스트 대상이 다양한 값을 어떻게 처리하는지 이해하기 어려울 때가 많다. 따라서 분할 식별은 신중하게 해야 한다.
유효한 값을 포함하는 분할을 유효 분할이라고 한다. 유효하지 않은 값을 포함하는 분할을 비유효 분할이라고 한다. 유효한 값과 유효하지 않은 값의 정의는 팀과 조직마다 다를 수 있다. 예를 들어, 테스트 대상이 처리해야 하는 값 또는 명세에 처리가 정의된 값을 유효 값으로 해석할 수 있다. 비유효 값은 테스트 대상이 무시하거나 거부해야 하는 값, 또는 테스트 대상 명세에 처리방법이 정의되어 있지 않은 값으로 해석할 수 있다.
동등 분할에서 커버리지 항목은 각 분할이 된다. 이 테스트 기법으로 100% 커버리지를 달성하려면 테스트 케이스로 각 분할을 최소 한 번씩 다뤄서 식별한 모든 분할(비유효 분할 포함)이 실행되도록 해야 한다. 커버리지는 하나 이상의 테스트 케이스로 실행한 분할 수를, 식별한 총 분할 수로 나눈 값으로 측정하며 백분율로 표시한다.
많은 테스트 항목이 다수의 분할 집합(예: 입력 변수가 2개 이상인 테스트 대상)을 가지고 있기 때문에 하나의 테스트 케이스는 여러 분할 집합에 속한 분할을 다루게 된다. 분할 집합이 다수인 경우, 가장 간단한 커버리지 기준을 이치 초이스 커버리지(Each Choice coverage)라고 한다(Ammann 2016). 이치 초이스 커버리지는 테스트 케이스가 모든 분할 집합의 각 분할을 최소 한 번은 실행할 것을 요구한다. 이치 초이스 커버리지에서는 분할의 조합을 고려하지 않는다.
4.2.2. 경계값 분석
경계값 분석(BVA)은 동등 분할의 경계 실행을 기반으로 하는 테스트 기법이다. 따라서 경계값 분석은 정렬된 분할에만 사용할 수 있다. 분할의 최솟값과 최댓값이 경계값이 된다. 경계값 분석에서 두 값이 같은 분할에 속하는 경우, 둘 사이의 모든 값도 해당 분할에 속해야 한다.
개발자가 분할의 경계에 있는 값을 다룰 때 오류를 범할 가능성이 높기 때문에 경계값 분석은 분할의 경계에 있는 값에 초점을 두게 된다. 경계값 분석으로 많이 찾는 결함은 구현된 경계가 의도한 위치보다 위나 아래에 잘못 배치됐거나 아예 누락된 결함이다.
이 실러버스는 두 가지 유형의 경계값 분석, 즉 두 개 선택(2개 값, 2-value)과 세 개 선택(3개 값, 3-value) 경계값 분석을 다룬다. 이 두 가지 유형은 100% 커버리지 달성을 위해 실행해야 하는 경계별 커버리지 항목의 수에서 차이가 난다.
두 개 선택 경계값 분석(Craig 2002, Myers 2011)은 각 경계값에 대해 두 개의 커버리지 항목을 도출한다.
경계값과
인접 분할에 속한 가장 가까운 값이 커버리지 항목이다. 두 개 선택 경계값 분석에서 100% 커버리지를 달성하려면, 테스트 케이스로 모든 커버리지 항목, 즉 식별한 모든 경계값을 실행해야 한다. 커버리지는 실행한 경계값의 수를 식별한 경계값의 총수로 나눈 값으로 백분율로 표시한다.
세 개 선택 경계값 분석(Koomen 2006, O'Regan 2019)은 각 경계값에 대해 세 개의 커버리지 항목을 도출한다. 경계값과 이웃한 양쪽의 값 모두가 커버리지 항목이다. 따라서 세 개 선택 경계값 분석에서는 경계값이 아닌 커버리지 항목도 있을 수 있다. 세 개 선택 경계값 분석에서 100% 커버리지를 달성하려면, 테스트 케이스로 모든 커버리지 항목, 즉 식별한 경계값과 그 이웃 값을 실행해야 한다. 커버리지는 실행한 경계값과 이웃한 값의 수를, 식별한 경계값과 이웃 값의 총수로 나눈 값으로 측정하며 백분율로 표시한다.
세 개 선택 경계값 분석은 두 개 선택 경계값 분석으로 발견하지 못한 결함을 식별할 수 있으므로 두 개 선택 경계값 분석보다 더 엄격하다고 할 수 있다. 예를 들어, "if (x≤10) ..."이라는 결정 구문이 "if (x=10) ..."으로 잘못 구현된 경우, 두 개 선택 경계값 분석으로 도출한 테스트 데이터(x=10, x=11)는 결함을 식별할 수 없다. 그러나 세 개 선택 경계값 분석으로 도출한 x=9는 이를 식별할 가능성이 크다.

4.2.3. 결정 테이블 테스팅
결정 테이블은 서로 다른 조건 조합으로 달라지는 결과를 나타내는 방식으로 요구사항이 제대로 구현되었는지를 테스트하는 데 사용한다. 결정 테이블은 비즈니스 규칙과 같은 복잡한 논리를 기록하는 효과적인 방법이다.
결정 테이블을 만들 때 조건들과 그에 따른 시스템의 동작 결과를 정의한다. 이것이 테이블의 행을 구성한다. 열은 각각 하나의 결정 규칙을 나타내며, 어떤 고유한 조건 조합을 연관 동작과 함께 정의한다. 제한-입력(limited-entry) 결정 테이블은 모든 조건과 동작 결괏값(관련 없거나 실행 불가능한 값 제외; 아래 참조)을 부울값(Boolean value. 참 또는 거짓)으로 표시한다. 확장-입력(extended-entry) 결정 테이블은 조건 및 동작 결괏값의 일부 또는 전부가 복수의 값(예: 숫자 범위, 동등 분할, 불연속 값)을 취할 수 있다.
조건의 표기법은 다음과 같다: "T"(참)는 조건이 충족됨을 의미한다. "F"(거짓)는 조건이 충족되지 않았음을 의미한다. "–"는 해당 조건 값이 결과에 영향이 없음을 의미한다. "N/A"는 해당 규칙에서 조건이 실행 불가능함을 의미한다. 결과 동작은 다음과 같다: "X"는 동작이 발생해야 함을 의미한다. 공백은 동작이 발생하지 않아야 함을 의미한다. 기타 표기법도 사용 가능하다.
전체 결정 테이블에는 모든 조건 조합을 포함할 수 있는 충분한 열이 있다. 실현 불가능한 조건 조합 열을 삭제해 테이블을 더 단순화 할 수 있다. 일부 조건이 결과에 영향을 미치지 않는 열들을 하나로 병합해 테이블을 최소화할 수도 있다. 결정 테이블 최소화를 위한 알고리즘은 이 실러버스의 범위를 벗어난다.
결정 테이블 테스팅에서 커버리지 항목은 실현 가능한 조건 조합을 가진 열이 된다. 이 기법으로 100% 커버리지를
달성하려면, 테스트 케이스가 이런 열을 모두 실행해야 한다. 커버리지는 실행된 열의 수를 실행 가능한 열의 총수로 나눈 값으로 측정하며 백분율로 표시한다.
결정 테이블 테스팅의 강점은 간과했을 수도 있는 조합을 포함한 모든 조건 조합을 식별하는 체계적인 방법을 제공한다는 점이다. 또한, 누락되거나 모순되는 요구사항을 찾는 데 도움이 된다. 조건의 수에 따라 규칙의 수는 기하급수적으로 늘어나기 때문에, 조건이 많으면 모든 결정 규칙을 실행하는 데 오랜 시간이 걸릴 수 있다. 이런 경우, 실행해야 하는 규칙의 수를 줄이기 위해 결정 테이블을 최소화하거나, 리스크 기반 접근법을 사용할 수 있다.
4.2.4. 상태 전이 테스팅
상태 다이어그램(state diagram)은 가능한 상태와 유효한 상태 전이를 표시해 시스템 동작을 모델링한다. 전이는 하나의 이벤트에 의해 발생하며, 별도의 가드(guard) 조건이 있을 수 있다. 전이는 즉각적인 것으로 간주되며, 가끔 소프트웨어의 어떤 동작으로 연결되기도 한다. 전이를 표시하는 형식은 보통 다음과 같다: "이벤트 [가드 조건] / 동작". 가드 조건과 동작이 없거나, 테스터와 관련이 없는 경우 생략될 수 있다.
상태 테이블은 상태 다이어그램을 다르게 표현한 모델이다. 행(rows)은 상태를 나타내고, 열(columns)은 이벤트를 (가드 조건이 있는 경우 함께) 나타낸다. 테이블 항목(셀, cell)은 전이(transition)를 나타내며, 정의되어 있는 경우에는 목표 상태(target state)와 그에 따른 결과 동작도 포함한다. 상태 전이 다이어그램과 달리 상태 테이블은 유효하지 않은 전이를 빈 셀로 명확하게 보여준다.
상태 다이어그램이나 상태 테이블을 기반으로 하는 테스트 케이스는 보통 일련의 이벤트 순서와 그 결과로 생기는 상태 변화로 (그리고 필요하다면 동작으로도) 표현된다. 하나의 테스트 케이스는 대부분의 경우 여러 개의 상태 전이를 포함한다.
상태 전이 테스팅에는 여러 가지 커버리지 측정 기준이 있다. 이 실러버스는 그 중에서 다음 세 가지를 설명한다:
모든 상태 커버리지(All state coverage)에서 커버리지 항목은 상태이다. 100% 상태 커버리지를 달성하려면, 모든 상태가 실행되도록 테스트 케이스를 구성해야 한다. 커버리지는 실행된 상태 수를 전체 상태 수로 나눈 값으로 측정하고 백분율로 표시한다.
유효 전이 커버리지(Valid transitions coverage, 0-스위치 커버리지라고도 함)에서는 각 유효 전이가 커버리지 항목이 된다. 유효 전이 커버리지 100%를 달성하려면, 테스트 케이스가 모든 유효 전이를 실행해야 한다. 커버리지는 실행된 유효 전이 수를 총 유효 전이 수로 나눈 값으로 측정하며 백분율로 표시한다.
모든 전이 커버리지(All transitions coverage)에서 커버리지 항목은 상태 테이블에 표시된 모든 전이들이다. 모든 전이 커버리지 100%를 달성하려면 테스트 케이스로 모든 유효 전이를 실행하고, 유효하지 않은 비유효 전이의 실행도 시도해야 한다. 하나의 테스트 케이스에서 오직 하나의 비유효 전이만을 테스트하는 것은 결함 마스킹(fault masking)을 방지하는 데 도움이 된다. 즉 하나의 결함이 다른 결함 탐지를
방해하는 상황을 방지할 수 있다. 커버리지는 실행된 테스트 케이스로 수행하거나, 커버하려고 시도한 유효 및 비유효 전이 수를 총 유효 및 비유효 전이 수로 나눈 값으로 측정하며 백분율로 표시한다.
모든 상태 커버리지는 일반적으로 모든 전이를 실행하지 않고도 달성할 수 있기 때문에, 유효 전이 커버리지보다 약하다. 유효 전이 커버리지는 가장 널리 사용하는 커버리지 조건이다. 유효 전이 커버리지 100%를 달성하면, 모든 상태 커버리지도 달성된다. 모든 전이 커버리지를 100% 달성하면, 모든 상태 커버리지와 유효 전이 커버리지도 모두 보장된다. 미션(mission)과 안전에 치명적인 소프트웨어의 경우, 이것을 충족해야 할 최소 기준으로 삼아야 한다.

화이트박스 테스트 기법
이번 절은 코드를 대상으로 한 화이트박스 테스트 기법 중, 간단하면서 널리 사용하는 아래 두 가지를 다룬다:
• 구문 테스팅
• 분기 테스팅
안전이나 미션에 치명적이거나 무결성이 높아야 하는 환경에서는 보다 철저한 코드 커버리지를 달성하기 위해 사용하는 보다 엄격한 화이트박스 기법이 사용된다. 또한, 상위 테스트 레벨(예: API 테스트)에 사용하거나, 코드와 관련 없는 커버리지(예: 신경망 테스트에서 뉴런 커버리지)를 사용하는 화이트박스 테스트 기법도 있다. 이런 기법은 이 실러버스에서 다루지 않는다.
4.3.1. 구문 테스팅과 구문 커버리지
구문 테스팅에서 커버리지 항목은 실행 가능한 구문이 된다. 목적은 코드 구문을 실행하는 테스트 케이스를 설계해서 허용할 수 있는 수준의 커버리지를 달성하는 것이다. 커버리지는 테스트 케이스가 실행한 구문 수를 코드의 실행 가능한 구문 총수로 나누어 계산하며 백분율로 표시한다.
100% 구문 커버리지를 달성하면 코드의 모든 실행 가능한 구문을 적어도 한 번은 실행했다는 것이 보장된다. 이는 결함이 있는 모든 구문도 실행해 결함 존재를 식별할 수 있는 장애가 나타났어야 함을 의미한다고 여길 수 있다. 그러나 테스트 케이스로 구문을 실행했다고 해서 결함이 반드시 식별되는 것은 아니다. 예를 들어, 데이터에 종속적인 결함(예: 분모를 0으로 설정한 경우에만 실패하는 나눗셈)은 식별하지 못할 수 있다. 또한, 100% 구문 커버리지가 모든 결정 논리를 테스트했다고 보장하는 것도 아니다. 예를 들어, 코드의 모든 분기(4.3.2 참조)가 실행되지 않았을 수 있다.
4.3.2. 분기 테스팅과 분기 커버리지
분기는 제어 흐름 그래프에서 두 노드(nodes) 간 제어의 이동으로 테스트 대상에서 소스 코드 구문의실행
가능 순서를 보여준다. 제어의 이동은 조건 없이(즉, 직선적 코드(straight-line code)) 또는 조건에 따라 이루어질 수 있다(즉, 결정문 결과).
분기 테스팅에서 커버리지 항목은 분기이며, 목적은 코드의 분기를 실행하는 테스트 케이스를 설계해서 허용할 수 있는 수준의 커버리지를 달성하는 것이다. 커버리지는 테스트 케이스가 실행한 분기 수를 분기 총수로 나눈 값으로 측정하며 백분율로 표시한다.
100% 분기 커버리지를 달성하면 코드의 모든 분기(무조건 및 조건 분기)를 테스트 케이스로 실행하게 된다. 조건 분기는 일반적으로 "if...then" 결정문의 참 또는 거짓 결과, 스위치/케이스 구문의 결과, 또는 루프(loop)에서 종료 또는 계속 여부의 결정에 부합한다. 그러나 테스트 케이스로 분기를 실행한다고 해서 반드시 결함을 식별할 수 있는 것은 아니다. 예를 들어, 코드의 특정 경로를 실행해야 하는 결함은 감지하지 못할 수 있다.
분기 커버리지는 구문 커버리지를 포함한다. 즉, 100% 분기 커버리지를 달성하는 테스트 케이스 집합은 100% 구문 커버리지도 달성하지만, 그 반대의 경우는 성립하지 않는다.
4.3.3. 화이트박스 테스팅의 가치
모든 화이트박스 테스트 기법이 가진 근본적인 강점은 테스트 중 전체 소프트웨어 구현을 고려하므로 소프트웨어 명세가 모호하거나 뒤떨어지고 불완전한 경우에도 결함을 쉽게 감지할 수 있다는 점이다. 반면에 소프트웨어가 하나 이상의 요구사항을 구현하지 않는 경우, 화이트박스 테스팅으로 그것이 누락됐다는 결함을 식별하지 못할 수 있다는 단점이 있다(Watson 1996).
화이트박스 테스트 기법은 정적 테스팅(예: 코드 드라이 런 중)에 사용할 수 있다. 아직 실행할 준비가 되지 않은 코드(Hetzel 1988) 외에도 슈도 코드(pseudocode) 또는 제어 흐름 그래프로 모델링할 수 있는 기타 상위 수준 및 하향식(top-down) 논리를 검토하는 데 적합하다.
블랙박스 테스팅만 수행해서는 실제 코드 커버리지 측정치를 얻을 수 없다. 화이트박스 커버리지 측정치는 객관적인 커버리지 측정값을 제공하고 이 커버리지를 높이기 위해 추가 테스트 생성을 위한 정보도 함께 제공함으로써, 코드 신뢰도를 높일 수 있다.

4.4. 경험 기반 테스트 기법
여기에서 다룰 널리 활용하는 경험 기반 테스트 기법은 다음과 같다:
• 오류 추정
• 탐색적 테스팅
• 체크리스트 기반 테스팅
4.4.1. 오류 추정
오류 추정이란 테스터의 지식을 기본으로 오류, 결함, 장애 발생을 예측하는 데 사용하는 테스트 기법이다. 테스터의 지식에는 다음이 포함된다:
• 애플리케이션의 과거 동작
• 개발자가 범하기 쉬운 오류 유형과 이런 오류로 인해 발생하는 결함 유형
• 다른 유사 애플리케이션에서 발생한 장애 유형
일반적으로 오류, 결함, 장애는 입력(예: 올바른 입력을 인식하지 못함, 매개변수 오류 또는 누락), 출력(예: 잘못된 형식, 잘못된 결과), 논리(예: 사례 누락, 잘못된 연산자), 계산(예: 잘못된 피연산자, 잘못된 계산), 인터페이스(예: 매개변수 불일치, 호환되지 않는 유형), 데이터(예: 잘못된 초기화, 잘못된 유형)와 관련이 있을 수 있다.
결함 공격은 오류 추정을 구현하는 방법 중 하나이다. 이 테스트 기법은 테스터가 발생 가능한 오류, 결함, 장애 목록을 만들거나 획득해서 오류와 관련된 결함을 식별 및 노출하거나, 장애를 유발하는 테스트를 설계하도록 한다. 이런 목록은 경험, 결함 및 장애 데이터 또는 소프트웨어에 문제가 생기는 원인에 관한 일반적인 지식을 기반으로 작성할 수 있다.
오류 추정과 결함 공격에 대한 자세한 내용은 Whittaker 2002, Whittaker 2003, Andrews 2006을 참조할 수 있다.
4.4.2. 탐색적 테스팅
탐색적 테스팅에서는 테스터가 테스트 대상에 대해 배워가면서 테스트의 설계, 실행, 평가를 동시에 하게 된다. 이 테스팅은 테스트 대상에 대해 더 배우고, 집중하고 있는 테스트는 더 깊이 탐색하고, 테스트되지 않은 영역에 대한 테스트를 만들기 위해 사용된다.
탐색적 테스팅은 때로 테스팅을 구조화하기 위해 세션 기반 테스팅을 사용하기도 한다. 세션 기반 접근법에서는 탐색적 테스팅을 시간을 정해 놓고 수행한다. 테스터는 테스트 목적이 정의된 테스트 차터(charter)를 테스팅 지침으로 사용한다. 일반적으로 테스트 세션이 끝나면 보고가 이어진다. 이때 테스터와 테스트 세션 결과에 관심이 있는 이해관계자 간의 토론이 이루어진다. 이 접근법에선 테스트 목적을 상위 수준의 테스트 컨디션으로 취급할 수 있다. 커버리지 항목은 테스트 세션 중에 식별하고 실행한다. 테스터가 수행 절차와 발견 내용을 기록하기 위해 테스트 세션 시트를 사용할 수 있다.
탐색적 테스팅은 명세가 부족하거나 부적합할 경우, 또 테스트에 시간적 압박이 심할 때 유용하다. 탐색적 테스팅은 다른 공식 테스트 기법을 보완하기에도 유용하다. 테스터가 풍부한 경험과 도메인 지식을 가지고 있고 높은 수준의 분석 기술, 호기심, 창의성 등 필요 기술을 갖춘 경우 탐색적 테스팅이 더욱 효과적일 수 있다(1.5.1 참조).
탐색적 테스팅 중 다른 테스트 기법(예: 동등 분할)을 사용할 수 있다. 탐색적 테스팅에 대한 자세한 내용은
Kaner 1999, Whittaker 2009, Hendrickson 2013에서 확인할 수 있다.

4.4.3. 체크리스트 기반 테스팅
체크리스트 기반 테스팅에서 테스터는 체크리스트를 활용해 테스트 컨디션을 확인하는 테스트를 설계, 구현, 실행한다. 체크리스트는 경험, 사용자에게 중요한 것이 무엇인지에 대한 지식, 또는 소프트웨어가 실패하는 이유와 방법에 대한 이해를 바탕으로 작성할 수 있다. 자동으로 점검할 수 있는 항목, 시작 조건, 종료 조건으로 더 적합한 항목, 너무 일반적인 항목은 체크리스트에 포함해서는 안 된다. (Brykczynski 1999)
체크리스트 항목을 질문 형식으로 표현하는 경우가 많다. 각 항목은 개별적이면서 직접적으로 확인할 수 있어야 한다. 이런 항목은 요구사항, 그래픽 인터페이스 속성, 품질 특성 또는 기타 유형의 테스트 컨디션일 수 있다. 체크리스트는 기능 및 비기능 테스트를 포함한 다양한 테스트 유형을 지원하기 위해 만들 수 있다(예: 사용성 테스트를 위한 10가지 휴리스틱 평가 기준(Nielsen 1994)).
시간이 지남에 따라 개발자가 같은 오류를 범하지 않게 됨으로 일부 체크리스트 항목은 점차 효과가 떨어질 수 있다. 새로 발견한 심각도가 높은 결함으로 인해 새로운 항목을 추가해야 할 수도 있다. 따라서 체크리스트는 결함 분석을 기반으로 정기적으로 업데이트해야 한다. 하지만 체크리스트가 너무 길어지지 않도록 주의할 필요가 있다. (Gawande 2009)
구체적인 테스트 케이스가 없는 경우에 체크리스트 기반 테스팅은 테스트를 위한 지침과 일정 수준의 일관성을 제공할 수 있다. 체크리스트가 상위 수준으로 작성된 경우 실제 테스트는 조금씩 달라질 수 있으며, 결국 커버리지는 높아지지만 재현 가능성은 떨어질 수 있다.

4.5. 협업 기반 테스트 접근법
위에서 언급한 각 테스트 기법(4.2, 4.3, 4.4 참조)은 결함 식별과 관련해 특정 목표를 가진다. 반면 협업 기반 접근법은 협업과 커뮤니케이션을 통한 결함 예방에도 초점을 둔다.
4.5.1. 협업 기반 사용자 스토리 작성
사용자 스토리는 시스템이나 소프트웨어의 사용자 또는 구매자에게 가치를 제공하는 기능을 나타낸다. 사용자 스토리는 다음 세 가지 중요 요소를 가지고 있으며(Jeffries 2000), 이를 합쳐서 '3C'라고 부른다.
• 카드(Card) - 사용자 스토리를 설명하는 매체(예: 인덱스 카드, 전자 게시판 항목)
• 대화(Conversation) - 소프트웨어 사용 방법에 대한 설명(문서 또는 구두로)
• 확인(Confirmation) - 인수 조건(4.5.2 참조)
사용자 스토리의 가장 일반적인 형식은 "[역할]로서 [목표]를 달성해 [역할이 얻게 될 비즈니스 가치]를 얻기를 원한다."이며, 이 후 인수 조건이 뒤따르는 형식이다.
협업 기반 사용자 스토리 작성은 브레인스토밍, 마인드 매핑과 같은 기법을 사용한다. 협업을 통해 팀원들은 비즈니스, 개발, 테스팅의 세 가지 관점을 고려해 만들어서 전달할 것에 대한 공유된 비전을 얻을 수 있다.
좋은 사용자 스토리는 독립적(Independent)이고, 협상 가능(Negotiable)하고, 가치 있고(Valuable), 추정 가능(Estimable)하고, 작고(Small), 테스트 가능(Testable)해야 한다(INVEST). 이해관계자가 사용자 스토리를 테스트하는 방법을 모른다면, 그 사용자 스토리가 명확하지 않거나 사용자에게 중요한 내용이 반영되어 있지 않거나, 이해관계자가 테스트를 수행하는 데 있어 도움이 필요하다는 것을 의미할 수 있다 (Wake 2003).
4.5.2. 인수 조건
사용자 스토리의 인수 조건은 사용자 스토리 구현 결과를 이해관계자가 승인하기 위해 충족되어야 하는 조건이다. 이런 관점에서 인수 조건을 테스트해야 하는 테스트 컨디션으로 볼 수 있다. 인수 조건은 보통 3C 중 대화(Conversation)를 통해 결정된다(4.5.1 참조).
인수 조건은 다음을 위해 사용된다:
• 사용자 스토리 범위 정의
• 이해관계자 간 합의 도출
• 긍정과 부정 시나리오 설명
• 사용자 스토리 인수 테스팅의 베이시스 제공(4.5.3 참조)
• 정확한 계획 및 추정
다양한 사용자 스토리의 인수 조건 작성법이 있으며, 가장 일반적인 두 가지는 다음과 같다:
• 시나리오 기반(예: 행위 주도 개발에서 사용하는 Given/When/Then 형식, 2.1.3 참조)
• 규칙 기반(예: 베리피케이션이 필요한 목록 또는 표로 표현된 입력-출력 매핑)
대부분의 인수 조건은 이 두 가지 형식 중 하나로 문서화할 수 있다. 그러나 팀이 다른 자체 형식을 사용하기로 할 수도 있으며, 이때도 인수 조건이 잘 정의되어 모호하지 않아야 한다.

4.5.3. 인수 테스트 주도 개발(ATDD)
인수 테스트 주도 개발(ATDD, Acceptance Test-driven Development)은 테스트 우선 접근법이다(2.1.3 참조). 테스트 케이스는 사용자 스토리 구현 전에 만들어진다. 고객, 개발자, 테스터 등 서로 다른 관점을 가진 팀원들이 테스트 케이스를 만든다(Adzic 2009). 테스트 케이스는 수동 또는 자동으로 실행할 수 있다.
첫 번째 단계는 명세 워크숍으로 팀원들은 여기서 사용자 스토리와 (아직 정의되지 않은 경우) 인수 조건을 분석하고 토론해서 작성한다. 이 과정에서 사용자 스토리의 불완전성, 모호성, 결함을 해결하게 된다. 다음
단계는 테스트 케이스를 만드는 것이다. 이 작업은 팀 전체가 수행하거나 테스터가 개별적으로 수행할 수 있다. 테스트 케이스는 인수 조건을 기반으로 하며, 소프트웨어가 어떻게 작동하는지에 대한 예제로 볼 수 있다. 이는 팀이 사용자 스토리를 올바르게 구현하는 데 도움을 준다.
여기서 예제와 테스트는 같은 의미를 가지기 때문에 혼용해서 사용하기도 한다. 테스트 설계 시 4.2, 4.3, 4.4에서 설명한 테스트 기법을 적용할 수 있다.
일반적으로 첫 번째 테스트 케이스는 예외나 오류 조건 없이 올바른 동작을 확인하고 모든 것이 예상대로 진행될 경우 실행되는 일련의 활동으로 구성된 긍정/유효 테스트 케이스이다. 유효 테스트 케이스를 끝내고 나면 팀은 비유효/부정 테스트를 수행해야 한다. 마지막으로, 팀은 비기능 품질 특성들(예: 성능 효율성, 사용성)도 다루어야 한다. 테스트 케이스는 이해관계자가 이해할 수 있는 방식으로 표현되어야 한다. 일반적으로 테스트 케이스는 (있는 경우) 필요한 전제 조건, 입력값, 사후 조건을 포함하며 자연어 문장으로 구성한다.
테스트 케이스는 사용자 스토리의 모든 특성을 다뤄야 하며 스토리를 벗어나면 안 된다. 그러나 인수 조건이 사용자 스토리가 얘기하는 문제의 일부를 구체적으로 설명할 수도 있다. 또한, 두 개 이상의 테스트 케이스가 사용자 스토리의 같은 특성을 설명해서는 안 된다.
테스트 자동화 프레임워크가 지원하는 형식으로 작성하면 개발자는 사용자 스토리에서 설명하는 기능을 구현할 때 필요한 코드를 작성해 테스트 케이스를 자동화할 수 있다. 그러면 인수 테스트가 실행 가능한 요구사항이 된다.
